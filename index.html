<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Diablo Immortal Node Builder</title>
    <script src="https://unpkg.com/react@18/umd/react.production.min.js"></script>
    <script src="https://unpkg.com/react-dom@18/umd/react-dom.production.min.js"></script>
    <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
    <script src="https://cdn.tailwindcss.com"></script>
    <link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css" rel="stylesheet">
    <style>
        body { background-color: #0f172a; color: #cbd5e1; overflow: hidden; font-family: 'Segoe UI', sans-serif; }
        .sidebar-scroll::-webkit-scrollbar { width: 6px; }
        .sidebar-scroll::-webkit-scrollbar-thumb { background: #475569; border-radius: 3px; }
        
        .node { transition: box-shadow 0.2s, transform 0.1s; user-select: none; }
        .node:hover { box-shadow: 0 0 15px rgba(34, 211, 238, 0.5); z-index: 50; }
        .node.selected { border-color: #22d3ee; box-shadow: 0 0 20px rgba(34, 211, 238, 0.8); }
        
        .socket-handle { transition: transform 0.2s; }
        .socket-handle:hover { transform: scale(1.5); background-color: #22d3ee; }

        .spline-path { fill: none; stroke-width: 3px; stroke-linecap: round; transition: stroke 0.2s; cursor: pointer; pointer-events: stroke; }
        .spline-path:hover { stroke: #f87171; stroke-width: 5px; }
        
        /* Types Colors */
        .type-core { background: radial-gradient(circle at center, #1e293b, #0f172a); border-color: #f8fafc; }
        .type-slot { background: #334155; border-color: #94a3b8; border-style: dashed; }
        .type-item { background: #0f172a; border-color: #f59e0b; } /* Legendary Orange */
        .type-set { background: #0f172a; border-color: #10b981; } /* Set Green */
        .type-gem { background: #1e1b4b; border-color: #a855f7; }
        .type-skill { background: #164e63; border-color: #06b6d4; }

        .anim-dash { animation: dash 1s linear infinite; }
        @keyframes dash { to { stroke-dashoffset: -20; } }
    </style>
</head>
<body>
    <div id="root"></div>

    <script type="text/babel">
        const { useState, useEffect, useRef, useMemo } = React;

        // --- CONSTANTS ---
        const SLOT_TEMPLATE = [
            { id: "core_char", type: "core", name: "Tempest Core", x: 600, y: 400 },
            { id: "slot_head", type: "slot_head", name: "Head Slot", x: 600, y: 200 },
            { id: "slot_chest", type: "slot_chest", name: "Chest Slot", x: 600, y: 300 },
            { id: "slot_legs", type: "slot_legs", name: "Legs Slot", x: 600, y: 500 },
            { id: "slot_mh", type: "slot_mainhand", name: "Main Hand", x: 400, y: 350 },
            { id: "slot_oh", type: "slot_offhand", name: "Off Hand", x: 800, y: 350 },
        ];

        // --- COMPONENTS ---

        const App = () => {
            const [libraryData, setLibraryData] = useState(null);
            const [nodes, setNodes] = useState([]);
            const [connections, setConnections] = useState([]); // { id, from, to }
            
            // Viewport
            const [pan, setPan] = useState({ x: 0, y: 0 });
            const [zoom, setZoom] = useState(1);
            
            // Interaction
            const [dragNode, setDragNode] = useState(null); // { id, startX, startY, offsetX, offsetY }
            const [linkStart, setLinkStart] = useState(null); // { id, x, y }
            const [mousePos, setMousePos] = useState({ x: 0, y: 0 });
            const [selectedNodeId, setSelectedNodeId] = useState(null);
            const [availableFiles, setAvailableFiles] = useState([]); // Simulated directory

            // Refs
            const canvasRef = useRef(null);
            const fileInputRef = useRef(null);

            // --- INITIALIZATION ---
            
            // Load default template on start if data exists
            useEffect(() => {
                if (libraryData && nodes.length === 0) {
                    setNodes(SLOT_TEMPLATE.map(t => ({...t, data: { name: t.name }})));
                    // Pre-connect slots to core
                    const newConns = SLOT_TEMPLATE
                        .filter(n => n.id !== 'core_char')
                        .map((n, i) => ({ 
                            id: `c_init_${i}`, 
                            from: 'core_char', 
                            to: n.id 
                        }));
                    setConnections(newConns);
                }
            }, [libraryData]);

            // --- HELPERS ---

            const generateId = () => Math.random().toString(36).substr(2, 9);

            const checkCompatibility = (sourceId, targetId) => {
                if (!libraryData || !libraryData.compatibility_rules) return true;
                const sourceNode = nodes.find(n => n.id === sourceId);
                const targetNode = nodes.find(n => n.id === targetId);
                if (!sourceNode || !targetNode) return false;

                // Rule: Source Type -> allows -> Target Type
                // Look up source type in rules
                const allowed = libraryData.compatibility_rules[sourceNode.type];
                if (allowed && allowed.includes(targetNode.type)) return true;

                // Reverse check (Connecting Item to Slot)
                const allowedReverse = libraryData.compatibility_rules[targetNode.type];
                if (allowedReverse && allowedReverse.includes(sourceNode.type)) return true;

                return false;
            };

            const resolveCollisions = (activeNodeId, newX, newY) => {
                const nodeRadius = 60; 
                let resolvedX = newX;
                let resolvedY = newY;
                
                // Simple repulsion
                nodes.forEach(n => {
                    if (n.id === activeNodeId) return;
                    const dx = resolvedX - n.x;
                    const dy = resolvedY - n.y;
                    const dist = Math.sqrt(dx*dx + dy*dy);
                    const minDist = nodeRadius * 2 + 10; // Buffer

                    if (dist < minDist && dist > 0) {
                        // Push away
                        const factor = (minDist - dist) / dist;
                        resolvedX += dx * factor * 0.5;
                        resolvedY += dy * factor * 0.5;
                    }
                });
                return { x: resolvedX, y: resolvedY };
            };

            // --- HANDLERS ---

            const handleFileLoad = (e) => {
                const file = e.target.files[0];
                if (!file) return;
                
                const reader = new FileReader();
                reader.onload = (evt) => {
                    try {
                        const json = JSON.parse(evt.target.result);
                        setLibraryData(json);
                        // Simulate adding to dropdown
                        setAvailableFiles(prev => [...prev, { name: file.name, data: json }]);
                    } catch (err) {
                        alert("Invalid JSON");
                    }
                };
                reader.readAsText(file);
            };

            const handleSelectCharacter = (e) => {
                const idx = e.target.value;
                if (idx !== "") {
                    const selected = availableFiles[idx];
                    setLibraryData(selected.data);
                    // Reset graph on char switch? Maybe ask user. For now, reset.
                    setNodes([]); 
                    setConnections([]);
                }
            };

            const handleDrop = (e) => {
                e.preventDefault();
                const itemDataStr = e.dataTransfer.getData("application/json");
                if (!itemDataStr) return;
                
                const itemData = JSON.parse(itemDataStr);
                const rect = canvasRef.current.getBoundingClientRect();
                
                // Calculate drop position in World Space
                const dropX = (e.clientX - rect.left - pan.x) / zoom;
                const dropY = (e.clientY - rect.top - pan.y) / zoom;

                const newNode = {
                    id: generateId(),
                    type: itemData.type,
                    x: dropX,
                    y: dropY,
                    data: itemData
                };

                setNodes(prev => [...prev, newNode]);
            };

            const handleMouseDownNode = (e, id) => {
                e.stopPropagation();
                if (e.button !== 0) return; // Only left click
                
                // Check if clicking handle (handled separately) or body
                const node = nodes.find(n => n.id === id);
                setDragNode({ 
                    id, 
                    startX: e.clientX, 
                    startY: e.clientY, 
                    origX: node.x, 
                    origY: node.y 
                });
                setSelectedNodeId(id);
            };

            const handleStartLink = (e, id) => {
                e.stopPropagation();
                const node = nodes.find(n => n.id === id);
                setLinkStart({ id, x: node.x, y: node.y }); // Initial visual start
            };

            const handleCanvasMouseMove = (e) => {
                const rect = canvasRef.current.getBoundingClientRect();
                const worldX = (e.clientX - rect.left - pan.x) / zoom;
                const worldY = (e.clientY - rect.top - pan.y) / zoom;
                setMousePos({ x: worldX, y: worldY });

                if (dragNode) {
                    // Moving Node
                    const dx = (e.clientX - dragNode.startX) / zoom;
                    const dy = (e.clientY - dragNode.startY) / zoom;
                    
                    let newX = dragNode.origX + dx;
                    let newY = dragNode.origY + dy;

                    // Collision Check
                    const resolved = resolveCollisions(dragNode.id, newX, newY);
                    
                    setNodes(prev => prev.map(n => 
                        n.id === dragNode.id ? { ...n, x: resolved.x, y: resolved.y } : n
                    ));
                }
            };

            const handleCanvasMouseUp = (e) => {
                // End Drag
                setDragNode(null);

                // End Link
                if (linkStart) {
                    // Check if dropped on a node
                    // We do a hit test based on coordinates or simple elementFromPoint?
                    // Since SVG is pointer-events none usually, let's find nearest node within radius
                    const dropX = mousePos.x;
                    const dropY = mousePos.y;
                    
                    const targetNode = nodes.find(n => {
                        if (n.id === linkStart.id) return false;
                        const dist = Math.sqrt(Math.pow(n.x - dropX, 2) + Math.pow(n.y - dropY, 2));
                        return dist < 60; // Hit radius
                    });

                    if (targetNode) {
                        // Validate compatibility
                        if (checkCompatibility(linkStart.id, targetNode.id)) {
                            setConnections(prev => [...prev, { 
                                id: generateId(), 
                                from: linkStart.id, 
                                to: targetNode.id 
                            }]);
                        } else {
                            // Maybe show error tooltip
                            console.log("Incompatible connection");
                        }
                    }
                    setLinkStart(null);
                }
            };

            const handleWheel = (e) => {
                e.preventDefault();
                setZoom(prev => Math.min(Math.max(0.2, prev - e.deltaY * 0.001), 2));
            };

            const deleteConnection = (id) => {
                setConnections(prev => prev.filter(c => c.id !== id));
            };

            const deleteNode = (id) => {
                setNodes(prev => prev.filter(n => n.id !== id));
                setConnections(prev => prev.filter(c => c.from !== id && c.to !== id));
                setSelectedNodeId(null);
            };
            
            // Save/Load Logic
            const saveBuild = () => {
                const build = {
                    characterFile: libraryData?.metadata?.class || "Unknown",
                    nodes,
                    connections
                };
                const dataStr = "data:text/json;charset=utf-8," + encodeURIComponent(JSON.stringify(build));
                const a = document.createElement('a');
                a.href = dataStr;
                a.download = `${build.characterFile}_build.json`;
                a.click();
            };

            const loadBuild = (e) => {
                const file = e.target.files[0];
                if(!file) return;
                const reader = new FileReader();
                reader.onload = (evt) => {
                    const build = JSON.parse(evt.target.result);
                    // In a real app we'd check build.characterFile against loaded library
                    setNodes(build.nodes);
                    setConnections(build.connections);
                };
                reader.readAsText(file);
            };

            // --- RENDER HELPERS ---

            const getNodeColor = (type) => {
                if (type === 'core') return 'type-core';
                if (type.includes('slot')) return 'type-slot';
                if (type.includes('item')) return 'type-item';
                if (type.includes('gem')) return 'type-gem';
                if (type.includes('skill')) return 'type-skill';
                if (type.includes('set')) return 'type-set';
                return 'bg-slate-700 border-slate-500';
            };

            return (
                <div className="w-screen h-screen flex bg-slate-900 text-slate-200">
                    
                    {/* Sidebar */}
                    <div className="w-80 bg-slate-800 border-r border-slate-700 flex flex-col z-20 shadow-xl">
                        <div className="p-4 border-b border-slate-700 bg-slate-900">
                            <h1 className="text-xl font-bold text-cyan-400 tracking-wider">Tempest<span className="text-white opacity-50">Graph</span></h1>
                            
                            {/* Character Loader */}
                            <div className="mt-4 space-y-2">
                                <label className="text-xs uppercase font-bold text-slate-500">1. Load Class Data (JSON)</label>
                                <div className="flex gap-2">
                                    <button onClick={() => fileInputRef.current.click()} className="flex-1 bg-cyan-900 hover:bg-cyan-800 text-cyan-200 text-xs py-2 rounded border border-cyan-700 transition">
                                        <i className="fas fa-folder-open mr-2"></i>Load Data
                                    </button>
                                    <input type="file" ref={fileInputRef} className="hidden" accept=".json" onChange={handleFileLoad} />
                                </div>
                                
                                {availableFiles.length > 0 && (
                                    <select onChange={handleSelectCharacter} className="w-full bg-slate-800 border border-slate-600 text-xs p-1 rounded text-slate-300">
                                        <option value="">Select Loaded Class...</option>
                                        {availableFiles.map((f, i) => <option key={i} value={i}>{f.name} ({f.data.metadata?.class})</option>)}
                                    </select>
                                )}
                            </div>

                            <div className="mt-4 pt-4 border-t border-slate-800">
                                <div className="flex gap-2">
                                    <button onClick={saveBuild} className="flex-1 bg-slate-700 hover:bg-slate-600 text-xs py-2 rounded transition"><i className="fas fa-save mr-1"></i> Save Build</button>
                                    <label className="flex-1 bg-slate-700 hover:bg-slate-600 text-xs py-2 rounded transition text-center cursor-pointer">
                                        <i className="fas fa-upload mr-1"></i> Load Build
                                        <input type="file" className="hidden" onChange={loadBuild} />
                                    </label>
                                </div>
                            </div>
                        </div>

                        <div className="flex-1 overflow-y-auto p-4 space-y-6 sidebar-scroll">
                            {!libraryData ? (
                                <div className="text-center text-slate-500 text-sm mt-10">
                                    <i className="fas fa-arrow-up mb-2 block"></i>
                                    Please load the tempest.json file to begin.
                                </div>
                            ) : (
                                <>
                                    {/* Library Items */}
                                    {['item', 'skill', 'gem', 'rune', 'curse', 'paragon'].map(category => {
                                        const items = libraryData.library.filter(i => i.type.includes(category));
                                        if (items.length === 0) return null;
                                        return (
                                            <div key={category}>
                                                <h3 className="text-xs font-bold text-slate-400 uppercase mb-2 border-b border-slate-700 pb-1">{category.replace('_', ' ')}s</h3>
                                                <div className="grid grid-cols-2 gap-2">
                                                    {items.map(item => (
                                                        <div 
                                                            key={item.id}
                                                            draggable
                                                            onDragStart={(e) => e.dataTransfer.setData("application/json", JSON.stringify(item))}
                                                            className="p-2 bg-slate-700/50 rounded border border-slate-600 hover:border-cyan-500 cursor-grab active:cursor-grabbing text-xs truncate transition"
                                                            title={item.properties?.description || item.name}
                                                        >
                                                            <i className={`fas ${item.icon || 'fa-cube'} mr-2 opacity-70`}></i>
                                                            {item.name}
                                                        </div>
                                                    ))}
                                                </div>
                                            </div>
                                        )
                                    })}
                                </>
                            )}
                        </div>
                    </div>

                    {/* Canvas Area */}
                    <div className="flex-1 relative bg-slate-950 overflow-hidden cursor-crosshair" 
                        ref={canvasRef}
                        onDrop={handleDrop} 
                        onDragOver={(e) => e.preventDefault()}
                        onMouseMove={handleCanvasMouseMove}
                        onMouseUp={handleCanvasMouseUp}
                        onWheel={handleWheel}
                        onMouseDown={(e) => {
                            if(e.button === 1 || e.button === 0) { // Middle or left click pan
                                // Implement Pan logic if needed, simpler to drag background
                            }
                        }}
                    >
                        {/* Grid */}
                        <div 
                            className="absolute inset-0 pointer-events-none opacity-20"
                            style={{
                                backgroundImage: 'radial-gradient(#334155 1px, transparent 1px)',
                                backgroundSize: '30px 30px',
                                transform: `translate(${pan.x}px, ${pan.y}px) scale(${zoom})`
                            }}
                        />

                        {/* World Container */}
                        <div 
                            className="absolute inset-0 origin-top-left"
                            style={{ transform: `translate(${pan.x}px, ${pan.y}px) scale(${zoom})` }}
                        >
                            {/* SVG Layer for Splines */}
                            <svg className="absolute top-0 left-0 w-[5000px] h-[5000px] pointer-events-visible">
                                {connections.map(conn => {
                                    const fromNode = nodes.find(n => n.id === conn.from);
                                    const toNode = nodes.find(n => n.id === conn.to);
                                    if (!fromNode || !toNode) return null;

                                    // Calculate spline
                                    const dist = Math.sqrt(Math.pow(toNode.x - fromNode.x, 2) + Math.pow(toNode.y - fromNode.y, 2));
                                    const controlOffset = dist * 0.5;

                                    // Simple Bezier
                                    const d = `M ${fromNode.x + 60} ${fromNode.y + 30} C ${fromNode.x + 60 + controlOffset} ${fromNode.y + 30}, ${toNode.x - 60 - controlOffset} ${toNode.y + 30}, ${toNode.x - 60} ${toNode.y + 30}`;
                                    // Use center points for cleaner look
                                    const startX = fromNode.x + 50; // width/2 approx
                                    const startY = fromNode.y + 30;
                                    const endX = toNode.x + 50;
                                    const endY = toNode.y + 30;
                                    const pathD = `M ${startX} ${startY} C ${startX + (endX - startX)/2} ${startY}, ${startX + (endX - startX)/2} ${endY}, ${endX} ${endY}`;

                                    return (
                                        <path 
                                            key={conn.id} 
                                            d={pathD} 
                                            className="spline-path stroke-slate-600 hover:stroke-red-500"
                                            onDoubleClick={() => deleteConnection(conn.id)}
                                        />
                                    );
                                })}

                                {/* Active Dragging Link */}
                                {linkStart && (
                                    <path 
                                        d={`M ${linkStart.x + 50} ${linkStart.y + 30} L ${mousePos.x} ${mousePos.y}`}
                                        className="stroke-cyan-400 stroke-2 anim-dash"
                                        strokeDasharray="5,5"
                                        fill="none"
                                    />
                                )}
                            </svg>

                            {/* HTML Nodes */}
                            {nodes.map(node => (
                                <div
                                    key={node.id}
                                    className={`absolute w-28 h-auto p-2 rounded border-2 flex flex-col items-center gap-1 node ${getNodeColor(node.type)} ${selectedNodeId === node.id ? 'selected' : ''}`}
                                    style={{ 
                                        left: node.x, 
                                        top: node.y,
                                        transform: 'translate(-50%, -50%)' // Center pivot
                                    }}
                                    onMouseDown={(e) => handleMouseDownNode(e, node.id)}
                                >
                                    <div className="text-[10px] uppercase font-bold text-slate-400 pointer-events-none">{node.type.replace('slot_', '').replace('item_', '')}</div>
                                    <div className="text-xs font-bold text-white text-center pointer-events-none truncate w-full px-1">
                                        {node.data.name}
                                    </div>
                                    
                                    {/* Node Info (CR, etc) */}
                                    {node.data.properties?.cr && (
                                        <div className="text-[9px] bg-black/30 rounded px-1 text-yellow-500 pointer-events-none">
                                            CR: {node.data.properties.cr}
                                        </div>
                                    )}

                                    {/* Link Handle */}
                                    <div 
                                        className="absolute -right-3 top-1/2 -translate-y-1/2 w-4 h-4 bg-slate-600 rounded-full border border-white cursor-pointer socket-handle hover:bg-cyan-500 z-50"
                                        onMouseDown={(e) => handleStartLink(e, node.id)}
                                        title="Drag to link"
                                    ></div>
                                    
                                    {/* Delete Button (Only shows when selected) */}
                                    {selectedNodeId === node.id && (
                                        <button 
                                            className="absolute -top-3 -right-3 bg-red-600 text-white rounded-full w-5 h-5 flex items-center justify-center text-xs shadow-lg z-50 hover:bg-red-500"
                                            onClick={(e) => { e.stopPropagation(); deleteNode(node.id); }}
                                        >
                                            <i className="fas fa-times"></i>
                                        </button>
                                    )}
                                </div>
                            ))}
                        </div>
                        
                        {/* Controls Overlay */}
                        <div className="absolute bottom-4 right-4 flex gap-2">
                            <button onClick={() => setZoom(z => z + 0.1)} className="bg-slate-800 text-white w-8 h-8 rounded border border-slate-700 hover:bg-slate-700">+</button>
                            <button onClick={() => setZoom(z => z - 0.1)} className="bg-slate-800 text-white w-8 h-8 rounded border border-slate-700 hover:bg-slate-700">-</button>
                        </div>

                        {/* Info Panel */}
                        {selectedNodeId && nodes.find(n => n.id === selectedNodeId)?.data.properties && (
                            <div className="absolute bottom-4 left-4 w-64 bg-slate-800/90 backdrop-blur p-4 rounded border border-slate-600 shadow-xl pointer-events-none select-text">
                                <h3 className="font-bold text-cyan-400 mb-2">{nodes.find(n => n.id === selectedNodeId).data.name}</h3>
                                <div className="space-y-1 text-xs text-slate-300">
                                    {Object.entries(nodes.find(n => n.id === selectedNodeId).data.properties).map(([k, v]) => (
                                        <div key={k}><span className="text-slate-500 uppercase mr-2">{k}:</span>{v}</div>
                                    ))}
                                </div>
                            </div>
                        )}
                    </div>
                </div>
            );
        };

        const root = ReactDOM.createRoot(document.getElementById('root'));
        root.render(<App />);
    </script>
</body>
</html>
