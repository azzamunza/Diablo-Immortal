<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Tempest Character Builder</title>
    <script src="https://unpkg.com/react@18/umd/react.production.min.js"></script>
    <script src="https://unpkg.com/react-dom@18/umd/react-dom.production.min.js"></script>
    <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
    <script src="https://cdn.tailwindcss.com"></script>
    <link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css" rel="stylesheet">
    <style>
        body { background-color: #020617; color: #e2e8f0; overflow: hidden; touch-action: none; font-family: 'Segoe UI', sans-serif; }
        .node-card { transition: box-shadow 0.2s, transform 0.1s; user-select: none; touch-action: none; }
        .node-card:hover { box-shadow: 0 0 20px rgba(6, 182, 212, 0.3); z-index: 50; }
        .socket { transition: all 0.2s; }
        .socket:hover { transform: scale(1.3); background-color: #22d3ee; box-shadow: 0 0 10px #22d3ee; }
        .socket.valid-target { background-color: #4ade80; box-shadow: 0 0 15px #4ade80; transform: scale(1.4); }
        .spline { fill: none; stroke-width: 3px; stroke-linecap: round; pointer-events: stroke; transition: stroke-width 0.2s; }
        .spline:hover { stroke-width: 6px; stroke: #ef4444; cursor: pointer; }
        .sidebar-item:active { cursor: grabbing; opacity: 0.7; }
        
        /* Rarity Styles */
        .rarity-legendary { border-color: #f59e0b; background: linear-gradient(145deg, #1e1b4b, #2d1b0e); }
        .rarity-common { border-color: #94a3b8; background: #0f172a; }
        .rarity-rare { border-color: #facc15; background: #0f172a; }
        
        /* Animations */
        @keyframes flow { to { stroke-dashoffset: -20; } }
        .connection-anim { animation: flow 1s linear infinite; }
    </style>
</head>
<body>
    <div id="root"></div>

    <script type="text/babel">
        const { useState, useEffect, useRef, useMemo } = React;

        const App = () => {
            const [data, setData] = useState(null);
            const [nodes, setNodes] = useState([]); // { id, x, y, defId, instanceData }
            const [connections, setConnections] = useState([]); // { id, fromNode, fromSocket, toNode, toSocket }
            
            // Interaction State
            const [pan, setPan] = useState({ x: 0, y: 0 });
            const [zoom, setZoom] = useState(1);
            const [dragNode, setDragNode] = useState(null); 
            const [drawLink, setDrawLink] = useState(null); // { fromNode, fromSocket, currentX, currentY }
            const [hoverSocket, setHoverSocket] = useState(null); // { nodeId, socketId }

            const canvasRef = useRef(null);
            const wrapperRef = useRef(null);

            // 1. Initialize: Load Tempest.json
            useEffect(() => {
                fetch('tempest.json')
                    .then(res => res.json())
                    .then(json => initializeCharacter(json))
                    .catch(err => console.log("Auto-load failed, waiting for user upload"));
            }, []);

            const initializeCharacter = (json) => {
                setData(json);
                // Create Root Node (The Character)
                const rootNode = {
                    id: "root_char",
                    x: window.innerWidth / 2 - 150,
                    y: window.innerHeight / 2 - 200,
                    isRoot: true,
                    data: {
                        name: json.class_info.name,
                        icon: "fa-user-astronaut",
                        stats: { "Base HP": json.class_info.base_hp, "Base Dmg": json.class_info.base_damage },
                        sockets: json.root_node_config.outputs // Root only has outputs (sockets to plug items INTO)
                    }
                };
                setNodes([rootNode]);
                setConnections([]);
            };

            // 2. Helper: Coordinates
            const getCanvasCoords = (e) => {
                const rect = wrapperRef.current.getBoundingClientRect();
                const clientX = e.touches ? e.touches[0].clientX : e.clientX;
                const clientY = e.touches ? e.touches[0].clientY : e.clientY;
                return {
                    x: (clientX - rect.left - pan.x) / zoom,
                    y: (clientY - rect.top - pan.y) / zoom
                };
            };

            // 3. Handlers: Node Dragging
            const handleNodePointerDown = (e, nodeId) => {
                e.stopPropagation();
                const coords = getCanvasCoords(e);
                const node = nodes.find(n => n.id === nodeId);
                setDragNode({ id: nodeId, offsetX: coords.x - node.x, offsetY: coords.y - node.y });
            };

            // 4. Handlers: Link Drawing
            const handleSocketPointerDown = (e, nodeId, socketId, side, typeAccepts) => {
                e.stopPropagation();
                e.preventDefault(); // Prevent text selection
                const coords = getCanvasCoords(e);
                setDrawLink({ 
                    fromNode: nodeId, 
                    fromSocket: socketId, 
                    startX: coords.x, 
                    startY: coords.y,
                    currX: coords.x, 
                    currY: coords.y,
                    side: side,
                    accepts: typeAccepts
                });
            };

            const handleSocketPointerUp = (e, nodeId, socketId, nodeType) => {
                e.stopPropagation();
                if (drawLink) {
                    // Validate Connection
                    if (drawLink.fromNode === nodeId) return; // Can't link to self
                    
                    // Check compatibility
                    // The 'accepts' array in the Root Node definition controls what plugs in
                    let isValid = false;
                    
                    if (drawLink.accepts && drawLink.accepts.includes(nodeType)) isValid = true;
                    
                    if (isValid) {
                        setConnections(prev => [
                            ...prev, 
                            { 
                                id: Math.random().toString(36).substr(2, 9),
                                fromNode: drawLink.fromNode,
                                fromSocket: drawLink.fromSocket,
                                toNode: nodeId,
                                toSocket: "input_main" // Simplified: Items have one main input point conceptually
                            }
                        ]);
                    }
                    setDrawLink(null);
                }
            };

            // 5. Global Pointer Move
            const handlePointerMove = (e) => {
                const coords = getCanvasCoords(e);

                if (dragNode) {
                    setNodes(prev => prev.map(n => 
                        n.id === dragNode.id 
                            ? { ...n, x: coords.x - dragNode.offsetX, y: coords.y - dragNode.offsetY }
                            : n
                    ));
                } else if (drawLink) {
                    setDrawLink(prev => ({ ...prev, currX: coords.x, currY: coords.y }));
                }
            };

            const handlePointerUp = () => {
                setDragNode(null);
                setDrawLink(null);
            };

            // 6. Adding Items from Sidebar
            const addItem = (defId) => {
                const def = data.library.find(i => i.id === defId);
                const newNode = {
                    id: Math.random().toString(36).substr(2, 9),
                    x: (-pan.x + 100) / zoom, // Drop near top left of visible area
                    y: (-pan.y + 100) / zoom,
                    defId: defId,
                    data: {
                        name: def.name,
                        icon: def.icon,
                        stats: def.stats,
                        type: def.type,
                        sockets: def.sockets || [] // Items might have gem sockets
                    }
                };
                setNodes(prev => [...prev, newNode]);
            };

            // 7. Math for Splines
            const calculatePath = (x1, y1, x2, y2, side1) => {
                // Bezier Control Point Offsets
                const dist = Math.sqrt(Math.pow(x2 - x1, 2) + Math.pow(y2 - y1, 2));
                const offset = Math.min(dist * 0.5, 150);
                
                let cp1x = x1, cp1y = y1;
                
                // Directional pulls based on side
                if (side1 === 'left') cp1x -= offset;
                if (side1 === 'right') cp1x += offset;
                if (side1 === 'bottom') cp1y += offset;
                if (side1 === 'top') cp1y -= offset;

                // Target is usually an item, let's assume items connect from center or appropriate side
                // For smoother visuals, if target is to the right, pull target left
                let cp2x = x2, cp2y = y2;
                if (x2 > x1) cp2x -= offset; else cp2x += offset;

                return `M ${x1} ${y1} C ${cp1x} ${cp1y}, ${cp2x} ${cp2y}, ${x2} ${y2}`;
            };

            // Get absolute coordinates of a socket
            const getSocketPos = (node, socketId, side, index, total) => {
                const width = 256; // w-64
                const height = node.isRoot ? 400 : 120; // h-auto
                
                // Approximation of socket DOM positions relative to node x,y
                let sx = node.x;
                let sy = node.y;

                if (node.isRoot) {
                    // Custom mapping for Root Node visual layout
                    if (side === 'left') { sx += 0; sy += 80 + (index * 50); }
                    if (side === 'right') { sx += width; sy += 80 + (index * 50); }
                    if (side === 'bottom') { sx += width/2; sy += height - 20; }
                } else {
                    // Items have a single "Input" usually at top or center
                    if (socketId === 'input_main') { sx += width/2; sy += 0; }
                    // Gem sockets
                    else { sx += width/2; sy += height; } 
                }
                return { x: sx, y: sy };
            };

            // --- RENDER ---

            if (!data) return (
                <div className="w-screen h-screen flex items-center justify-center flex-col bg-slate-900 text-slate-300">
                    <h1 className="text-3xl font-bold mb-4 text-cyan-400">Tempest Builder</h1>
                    <div className="p-8 border-2 border-dashed border-slate-600 rounded-xl bg-slate-800">
                        <p className="mb-4">Drag 'tempest.json' here or click to load.</p>
                        <input type="file" onChange={(e) => {
                            const f = e.target.files[0];
                            const r = new FileReader();
                            r.onload = (evt) => initializeCharacter(JSON.parse(evt.target.result));
                            r.readAsText(f);
                        }} />
                    </div>
                </div>
            );

            return (
                <div className="w-screen h-screen flex overflow-hidden">
                    {/* Sidebar */}
                    <div className="w-64 bg-slate-900 border-r border-slate-800 flex flex-col z-20 shadow-2xl shrink-0">
                        <div className="p-4 bg-slate-950 border-b border-slate-800">
                            <h2 className="text-xl font-bold text-cyan-500 uppercase tracking-widest">{data.class_info.name}</h2>
                            <p className="text-xs text-slate-500">Node Builder v2.0</p>
                        </div>
                        <div className="flex-1 overflow-y-auto p-2 space-y-4">
                            {['item', 'skill', 'gem', 'paragon'].map(cat => {
                                const items = data.library.filter(i => i.type.includes(cat));
                                if(!items.length) return null;
                                return (
                                    <div key={cat}>
                                        <h3 className="text-xs font-bold text-slate-400 uppercase mb-2 pl-2">{cat}s</h3>
                                        <div className="grid grid-cols-1 gap-2">
                                            {items.map(item => (
                                                <div 
                                                    key={item.id}
                                                    className="sidebar-item flex items-center gap-3 p-2 rounded bg-slate-800 border border-slate-700 hover:border-cyan-500 cursor-pointer transition select-none"
                                                    onPointerDown={() => addItem(item.id)}
                                                >
                                                    <div className="w-8 h-8 rounded bg-slate-900 flex items-center justify-center text-slate-400">
                                                        <i className={`fas ${item.icon}`}></i>
                                                    </div>
                                                    <div className="text-sm font-medium text-slate-200">{item.name}</div>
                                                </div>
                                            ))}
                                        </div>
                                    </div>
                                )
                            })}
                        </div>
                    </div>

                    {/* Canvas Wrapper */}
                    <div 
                        ref={wrapperRef}
                        className="flex-1 relative bg-slate-950 cursor-move touch-none"
                        onPointerMove={handlePointerMove}
                        onPointerUp={handlePointerUp}
                        onPointerLeave={handlePointerUp}
                        onPointerDown={() => { /* Implement Pan logic here if needed */ }}
                    >
                        {/* Background Grid */}
                        <div 
                            className="absolute inset-0 pointer-events-none opacity-20"
                            style={{
                                backgroundImage: 'radial-gradient(#334155 1px, transparent 1px)',
                                backgroundSize: '40px 40px',
                                transform: `translate(${pan.x}px, ${pan.y}px) scale(${zoom})`
                            }}
                        />

                        {/* Infinite Canvas */}
                        <div className="absolute inset-0 origin-top-left"
                             style={{ transform: `translate(${pan.x}px, ${pan.y}px) scale(${zoom})` }}>
                            
                            {/* SVG Layer */}
                            <svg className="absolute top-0 left-0 w-[5000px] h-[5000px] pointer-events-none overflow-visible z-0">
                                {connections.map(conn => {
                                    const fromN = nodes.find(n => n.id === conn.fromNode);
                                    const toN = nodes.find(n => n.id === conn.toNode);
                                    if(!fromN || !toN) return null;

                                    // Find socket config for Root to get precise position
                                    let side = 'right';
                                    let idx = 0;
                                    if (fromN.isRoot) {
                                        const s = fromN.data.sockets.find(s => s.id === conn.fromSocket);
                                        side = s?.side || 'right';
                                        // Calculate visual index for spacing
                                        const brothers = fromN.data.sockets.filter(sk => sk.side === side);
                                        idx = brothers.findIndex(sk => sk.id === conn.fromSocket);
                                    }

                                    const p1 = getSocketPos(fromN, conn.fromSocket, side, idx);
                                    const p2 = getSocketPos(toN, conn.toSocket, 'top', 0); // Items input is top/center

                                    return (
                                        <path 
                                            key={conn.id}
                                            d={calculatePath(p1.x, p1.y, p2.x, p2.y, side)}
                                            className="spline stroke-slate-500 pointer-events-auto"
                                            onDoubleClick={() => setConnections(prev => prev.filter(c => c.id !== conn.id))}
                                        />
                                    );
                                })}

                                {/* Active Draw Link */}
                                {drawLink && (
                                    <path 
                                        d={calculatePath(drawLink.startX, drawLink.startY, drawLink.currX, drawLink.currY, drawLink.side)}
                                        className="stroke-cyan-400 stroke-2 connection-anim fill-none"
                                        strokeDasharray="10,5"
                                    />
                                )}
                            </svg>

                            {/* Nodes Layer */}
                            {nodes.map(node => (
                                <div 
                                    key={node.id}
                                    className={`absolute w-64 bg-slate-900/95 backdrop-blur rounded-lg border-2 shadow-2xl flex flex-col node-card ${node.isRoot ? 'h-[500px] border-cyan-500/50' : `h-auto ${node.data.type === 'gem_legendary' ? 'border-purple-500' : 'rarity-' + (node.data.rarity || 'common')}`}`}
                                    style={{ 
                                        left: node.x, top: node.y,
                                        zIndex: dragNode?.id === node.id ? 100 : 10
                                    }}
                                    onPointerDown={(e) => handleNodePointerDown(e, node.id)}
                                >
                                    {/* Node Header */}
                                    <div className={`p-3 border-b ${node.isRoot ? 'bg-cyan-950/30 border-cyan-800' : 'bg-black/20 border-white/10'}`}>
                                        <div className="flex items-center gap-3">
                                            <div className={`w-10 h-10 rounded flex items-center justify-center text-xl shadow-inner ${node.isRoot ? 'bg-cyan-500 text-black' : 'bg-slate-800 text-slate-400'}`}>
                                                <i className={`fas ${node.data.icon}`}></i>
                                            </div>
                                            <div>
                                                <div className="font-bold text-sm text-slate-100 leading-tight">{node.data.name}</div>
                                                {!node.isRoot && <div className="text-[10px] uppercase text-slate-500">{node.data.type}</div>}
                                            </div>
                                        </div>
                                    </div>

                                    {/* Stats Body */}
                                    <div className="p-3 space-y-2 flex-1">
                                        {node.data.stats && Object.entries(node.data.stats).map(([k,v]) => (
                                            <div key={k} className="flex justify-between text-xs">
                                                <span className="text-slate-500 uppercase font-bold">{k}</span>
                                                <span className="text-slate-200 font-mono">{v}</span>
                                            </div>
                                        ))}
                                        {node.data.effect && (
                                            <div className="mt-2 text-[11px] text-yellow-100/80 italic leading-snug bg-yellow-900/10 p-2 rounded border border-yellow-500/10">
                                                "{node.data.effect}"
                                            </div>
                                        )}
                                    </div>

                                    {/* Sockets (Root Specific) */}
                                    {node.isRoot && (
                                        <>
                                            {/* Left Sockets */}
                                            <div className="absolute -left-3 top-20 flex flex-col gap-10">
                                                {node.data.sockets.filter(s => s.side === 'left').map(s => (
                                                    <Socket 
                                                        key={s.id} 
                                                        socket={s} 
                                                        nodeId={node.id}
                                                        onPointerDown={(e) => handleSocketPointerDown(e, node.id, s.id, s.side, s.accepts)} 
                                                    />
                                                ))}
                                            </div>
                                            {/* Right Sockets */}
                                            <div className="absolute -right-3 top-20 flex flex-col gap-10">
                                                {node.data.sockets.filter(s => s.side === 'right').map(s => (
                                                    <Socket 
                                                        key={s.id} 
                                                        socket={s} 
                                                        nodeId={node.id}
                                                        align="right"
                                                        onPointerDown={(e) => handleSocketPointerDown(e, node.id, s.id, s.side, s.accepts)} 
                                                    />
                                                ))}
                                            </div>
                                            {/* Bottom Sockets */}
                                            <div className="absolute bottom-0 w-full flex justify-center pb-2">
                                                {node.data.sockets.filter(s => s.side === 'bottom').map(s => (
                                                    <Socket 
                                                        key={s.id} 
                                                        socket={s} 
                                                        nodeId={node.id}
                                                        labelBottom
                                                        onPointerDown={(e) => handleSocketPointerDown(e, node.id, s.id, s.side, s.accepts)} 
                                                    />
                                                ))}
                                            </div>
                                        </>
                                    )}

                                    {/* Input Socket (For Items) */}
                                    {!node.isRoot && (
                                        <div 
                                            className="absolute -top-3 left-1/2 -translate-x-1/2 w-6 h-6 rounded-full bg-slate-700 border-2 border-slate-500 hover:border-white z-50 cursor-crosshair flex items-center justify-center"
                                            onPointerUp={(e) => handleSocketPointerUp(e, node.id, "input_main", node.data.type)}
                                        >
                                            <div className="w-2 h-2 bg-slate-400 rounded-full pointer-events-none"></div>
                                        </div>
                                    )}

                                    {/* Delete Btn */}
                                    {!node.isRoot && (
                                        <button 
                                            className="absolute -top-2 -right-2 w-6 h-6 bg-red-600 text-white rounded-full text-xs shadow-lg hover:bg-red-500 z-50"
                                            onPointerDown={(e) => { e.stopPropagation(); setNodes(prev => prev.filter(n => n.id !== node.id)); }}
                                        >
                                            <i className="fas fa-times"></i>
                                        </button>
                                    )}
                                </div>
                            ))}
                        </div>
                        
                        {/* Zoom Controls */}
                        <div className="absolute bottom-5 right-5 flex gap-2">
                            <button onClick={() => setZoom(z => Math.min(z + 0.1, 2))} className="w-10 h-10 bg-slate-800 text-white rounded border border-slate-700 shadow-lg">+</button>
                            <button onClick={() => setZoom(z => Math.max(z - 0.1, 0.5))} className="w-10 h-10 bg-slate-800 text-white rounded border border-slate-700 shadow-lg">-</button>
                        </div>
                    </div>
                </div>
            );
        };

        // Socket Sub-Component
        const Socket = ({ socket, nodeId, align = 'left', labelBottom = false, onPointerDown }) => {
            return (
                <div className="relative group flex items-center" style={{ flexDirection: align === 'right' ? 'row-reverse' : 'row' }}>
                    <div 
                        className="w-6 h-6 rounded-full bg-slate-800 border-2 border-cyan-600 socket cursor-crosshair shadow-lg shadow-cyan-900/50 z-50"
                        onPointerDown={onPointerDown}
                        title={socket.label}
                    ></div>
                    {/* Tooltip Label */}
                    <div className={`absolute ${labelBottom ? 'top-8 left-1/2 -translate-x-1/2' : (align === 'right' ? 'right-8' : 'left-8')} bg-black/80 text-cyan-400 text-[10px] uppercase font-bold px-2 py-1 rounded whitespace-nowrap opacity-0 group-hover:opacity-100 transition pointer-events-none`}>
                        {socket.label}
                    </div>
                </div>
            );
        };

        const root = ReactDOM.createRoot(document.getElementById('root'));
        root.render(<App />);
    </script>
</body>
</html>


